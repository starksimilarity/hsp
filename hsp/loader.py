"""module that defines history loaders

The root class is PBLoader, an AbstractBaseClass.  To implement a new loader,
inherit from PBLoader and implement the 'load' classmethod; then update the load_all
method to point a keyword to the class.

In the future, users will be able to create a new PBLoader and allow the sub-class
to register for histfile_typehint keywords directly without having to mod the 
master class.
"""

from abc import ABC, abstractmethod
import csv
import datetime as dt
from dateutil.parser import parse as parsedate
import json
import pickle
import re

from command import Command


class PBLoader(ABC):
    """Class that defines one abstract classmethod for loading a history

    Subclasses can be developed to load a particular type of file history,
    for example loading a file produced by the unix "script" command
    
    AbstractMethods
    ===============
    @classmethod
    @abstractmethod
    load(cls, filename) -> list[command.Command]
        load a history from a filename
    """

    @classmethod
    @abstractmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """Load a history from a filename

        Parameters
        ==========
        filename : str
            filename of the history file
        user_hint : str
            hint of what the user should be if not found in the history
        host_hint : str
            hint of what the hostUUID should be if not found in the history
        date_hint : str
            hint of what the date should be if not found in the history


        Returns
        =======
        list[command.Command]
            List of Command objects from the history
        """
        return []

    @classmethod
    def load_all(cls, session_folder, histfile, histfile_typehint=None, hints=None):
        if histfile_typehint == "pickle":
            return PicklePBLoader.load(f"{session_folder}/{histfile}", **hints)
        elif histfile_typehint == "msf_prompt":
            return OffPromptPBLoader.load(f"{session_folder}/{histfile}", **hints)
        elif histfile_typehint == "bash_hist":
            return BashHistoryPBLoader.load(f"{session_folder}/{histfile}", **hints)
        elif histfile_typehint == "generic_csv_hist":
            return GenericCsvPBLoader.load(f"{session_folder}/{histfile}", **hints)
        elif histfile_typehint == "generic_json_hist":
            return GenericJsonPBLoader.load(f"{session_folder}/{histfile}", **hints)
        else:
            return []


class PicklePBLoader(PBLoader):
    """Class for loading pickled lists of commands.
    """

    @classmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """Load history for pickled list of Commands

        This loader assumes that the pickle being loaded is already
        a list of Command objects.  It creates a new list to verify that
        what was loaded is in fact a list of Command objects and will drop
        anything that is not.

        Returns
        =======
        list[command.Command]
            List of Command objects from pickle file
        """

        commands = pickle.load(open(filename, "rb"))
        hist = [x for x in commands if isinstance(x, Command)]
        return hist


class OffPromptPBLoader(PBLoader):
    """Class for loading histories generated by an msf_prompt.OffPromptSession 
    """

    @classmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """Load log from msf_prompt.OffPromptSession

        For an OffPromptSession, a history only includes the command and timestamp,
        but the log file contains time, user, command, and result.  
        The format of an OffPromptSession log is :
            =================
            <time>
            [COMMAND][USER: <user>]
            <command>

            ...
            =================
            <time>
            [RESULT]
            <result>
        """
        commandhist = []
        rawhist = ""
        with open(filename, "r+") as infi:
            rawhist = infi.read()

        # future : consider making this more performant
        commands = re.findall(
            "=\n([0-9\-\W:,]+)\n"  # datetime
            "\[COMMAND\]\[USER: (.*?)\]\n"  # user
            "(.*?)={4,}.*?\[RESULT\]"  # command
            "(.*?)={8,}\n",  # result
            rawhist,
            re.DOTALL,
        )

        for c in commands:
            try:
                # datetime.datetime.fromisoformat would solve this perfectly,
                # but is not introduced until python 3.7
                yr, mon, day, hr, mn, sec = re.findall(
                    "([0-9]{4})-"  # yr
                    "([0-9]{2})-"  # mon
                    "([0-9]{2}) "  # day
                    "([0-9]{2}):"  # hr
                    "([0-9]{2}):"  # mn
                    "([0-9]{2})",
                    c[0],
                )[
                    0
                ]  # only expecting one result so grab the first and unpack

                # this portion isn't strictly necessary but it makes the
                # build of Command so much cleaner
                time = dt.datetime(
                    int(yr), int(mon), int(day), int(hr), int(mn), int(sec)
                )
                user = c[1]
                user_command = c[2].strip("+").strip()
                if user_command == "exit":
                    # this prevents the new session from being the "result" of exit
                    result = ""
                else:
                    result = c[3]

                commandhist.append(Command(time, user, "unknown", user_command, result))
            except Exception as e:
                print(e)

        return commandhist


class BashHistoryPBLoader(PBLoader):
    """Class for loading histories generated by bash terminal
    """

    @classmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """Loads bash terminal history files
        
        Bash histories are pretty sparse so passing hints is going to be valuable if able.
        Bash histories take the form of "num  command"--one on each line
        """
        commandhist = []
        base_date = date_hint or dt.datetime.fromordinal(1)

        with open(filename, "r+") as infi:
            for line in infi:
                try:
                    num, comm = line.split("  ", 1)
                    commandhist.append(
                        Command(
                            time=base_date + dt.timedelta(minutes=int(num)),
                            user=user_hint or "unknown",
                            hostUUID=host_hint or "unknown",
                            command=comm,
                        )
                    )
                except Exception as e:
                    print(e)
        return commandhist


class GenericCsvPBLoader(PBLoader):
    """Class for loading CSVs with the required columns

    Format of loaded CSVs must be 'time, host, user, command, result, flagged, comment'
    unless the first row is a list of headers in which case there can be any number of
    columns in any order.

    If there are errors loading, check to make sure the file is in unix dialect (not excel)

    # future: make this way more elegant and performant
    # future: incorporate hints and missing columns
    """

    @classmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """
        """

        commandhist = []

        with open(filename, "r+") as infi:
            header = False
            poss_headers = infi.readline()

            # since time is a mandatory field, check the first row
            # to see if the word time is one of the values;
            # if yes, treat the row as header
            for val in poss_headers.split(","):
                if val.lower().strip() == "time":
                    header = True

            infi.seek(0)

            if header:
                print("header found")
                csvreader = csv.DictReader(infi)
                for row in csvreader:
                    row = dict(
                        (k.lower().strip(), v) for k, v in row.items() if k is not None
                    )
                    try:
                        time = parsedate(row.get("time"))
                    except (TypeError, ValueError) as e:
                        try:
                            time = dt.datetime.fromordinal(int(time))
                        except:
                            raise

                    f = row.get("flagged", "").strip().lower()
                    if f == "true":
                        flagged = True
                    else:
                        flagged = False

                    commandhist.append(
                        Command(
                            time,
                            hostUUID=row.get("host", None),
                            user=row.get("user", None),
                            command=row.get("command", None),
                            result=row.get("result", None),
                            flagged=flagged,
                            comment=row.get("comment", ""),
                        )
                    )

            if not header:
                csvreader = csv.reader()
                for row in csvreader:
                    try:
                        time, host, user, command, result, flagged, comment, *_ = row
                        try:
                            time = parsedate(time)

                        except (TypeError, ValueError) as e:
                            try:
                                time = dt.datetime.fromordinal(int(time))
                            except:
                                raise

                        commandhist.append(
                            Command(
                                time=time,
                                hostUUID=host,
                                user=user,
                                command=command,
                                result=result,
                                flagged=bool(flagged),
                                comment=comment,
                            )
                        )
                    except Exception as e:
                        print(e)
        return commandhist


class GenericJsonPBLoader(PBLoader):
    """
    """

    @classmethod
    def load(cls, filename, user_hint=None, host_hint=None, date_hint=None):
        """Loads JSON saved history

        Assumed format is list of commands

        #NOT IMPLEMENTED
        """
        return []
